package postgres

import (
	"context"
	"fmt"
	"time"

	"github.com/Nexi77/fleetcommander-backend/internal/domain"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

type driverRepository struct {
	db      *pgxpool.Pool
	queries *Queries // Generated by sqlc
}

func NewDriverRepository(pool *pgxpool.Pool) domain.DriverRepository {
	return &driverRepository{
		db:      pool,
		queries: New(pool),
	}
}

func (r *driverRepository) Create(ctx context.Context, driver *domain.Driver) error {
	if driver.ID == uuid.Nil {
		driver.ID = uuid.New()
	}

	now := time.Now().UTC()
	driver.CreatedAt = now
	driver.UpdatedAt = now

	pgCreatedAt := pgtype.Timestamptz{Time: driver.CreatedAt, Valid: true}
	pgUpdatedAt := pgtype.Timestamptz{Time: driver.UpdatedAt, Valid: true}

	err := r.queries.CreateDriver(ctx, CreateDriverParams{
		ID:        driver.ID,
		Name:      driver.Name,
		Status:    DriverStatus(driver.Status), // Cast domain enum to sqlc enum
		CreatedAt: pgCreatedAt,
		UpdatedAt: pgUpdatedAt,
	})

	if err != nil {
		return fmt.Errorf("failed to insert driver via sqlc: %w", err)
	}

	return nil
}

func (r *driverRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.Driver, error) {
	row, err := r.queries.GetDriverByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get driver by id: %w", err)
	}

	// Translate sqlc generated struct back to our clean Domain Model
	return &domain.Driver{
		ID:        row.ID,
		Name:      row.Name,
		Status:    domain.DriverStatus(row.Status),
		CreatedAt: row.CreatedAt.Time,
		UpdatedAt: row.UpdatedAt.Time,
	}, nil
}

func (r *driverRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status domain.DriverStatus) error {
	now := time.Now().UTC()
	pgUpdatedAt := pgtype.Timestamptz{Time: now, Valid: true}

	err := r.queries.UpdateDriverStatus(ctx, UpdateDriverStatusParams{
		ID:        id,
		Status:    DriverStatus(status),
		UpdatedAt: pgUpdatedAt,
	})

	if err != nil {
		return fmt.Errorf("failed to update driver status: %w", err)
	}

	return nil
}

// UpdateLocation is an extra method specific to our implementation.
// We will add it to the domain interface later when we build the GPS ingestion pipeline.
func (r *driverRepository) UpdateLocation(ctx context.Context, id uuid.UUID, lon, lat float64) error {
	now := time.Now().UTC()
	pgUpdatedAt := pgtype.Timestamptz{Time: now, Valid: true}

	err := r.queries.UpdateDriverLocation(ctx, UpdateDriverLocationParams{
		Lon:       lon, // sqlc generates "Column1" and "Column2" for explicitly casted parameters like $1::float
		Lat:       lat,
		UpdatedAt: pgUpdatedAt,
		ID:        id,
	})

	if err != nil {
		return fmt.Errorf("failed to update driver location: %w", err)
	}

	return nil
}
